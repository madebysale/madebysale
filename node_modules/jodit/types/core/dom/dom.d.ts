/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Released under MIT see LICENSE.txt in the project root for license information.
 * Copyright (c) 2013-2022 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
import type { HTMLTagNames, ICreate, IJodit, NodeCondition, Nullable, IDictionary } from 'jodit/types';
export declare class Dom {
    static detach(node: Node): void;
    static wrapInline(current: Node, tag: Node | HTMLTagNames, editor: IJodit): HTMLElement;
    static wrap<K extends HTMLTagNames>(current: Node | Range, tag: HTMLElement, create: ICreate): HTMLElementTagNameMap[K];
    static wrap<K extends HTMLTagNames>(current: Node | Range, tag: K, create: ICreate): HTMLElementTagNameMap[K];
    static unwrap(node: Node): void;
    static between(start: Node, end: Node, callback: (node: Node) => void | boolean): void;
    static replace<T extends Node>(elm: Node, newTagName: HTMLTagNames | Node | string, create: ICreate, withAttributes?: boolean, notMoveContent?: boolean): T;
    static isEmptyTextNode(node: Nullable<Node>): boolean;
    static isEmptyContent(node: Node): boolean;
    static isContentEditable(node: Nullable<Node>, root: HTMLElement): boolean;
    static isEmpty(node: Node, condNoEmptyElement?: RegExp): boolean;
    static isNode(object: unknown): object is Node;
    static isCell(elm: unknown): elm is HTMLTableCellElement;
    static isImage(elm: unknown): elm is HTMLImageElement;
    static isBlock(node: unknown): node is HTMLDivElement;
    static isText(node: Node | null | false): node is Text;
    static isElement(node: unknown): node is Element;
    static isFragment(node: unknown): node is DocumentFragment;
    static isHTMLElement(node: unknown): node is HTMLElement;
    static isInlineBlock(node: Node | null | false): node is HTMLElement;
    static canSplitBlock(node: unknown): boolean;
    static last(root: Nullable<Node>, condition: NodeCondition): Nullable<Node>;
    static prev<T extends Node = Node>(node: Node, condition: NodeCondition, root: HTMLElement, withChild?: boolean): Nullable<T>;
    static next<T extends Node = Node>(node: Node, condition: NodeCondition, root: HTMLElement, withChild?: boolean): Nullable<T>;
    static prevWithClass(node: HTMLElement, className: string): Nullable<HTMLElement>;
    static nextWithClass(node: HTMLElement, className: string): Nullable<HTMLElement>;
    static find<T extends Node = Node>(node: Node, condition: NodeCondition, root: HTMLElement, leftToRight?: boolean, withChild?: boolean): Nullable<T>;
    static nextGen(start: Node, root: HTMLElement, leftToRight?: boolean, withChild?: boolean): Generator<Node>;
    static each(elm: Node, callback: (node: Node) => void | boolean, leftToRight?: boolean): boolean;
    static eachGen(root: Node, leftToRight?: boolean): Generator<Node>;
    private static runInStack;
    static findWithCurrent(node: Node, condition: NodeCondition, root: HTMLElement | Node, sibling?: 'nextSibling' | 'previousSibling', child?: 'firstChild' | 'lastChild'): Nullable<Node>;
    static findSibling(node: Node, left?: boolean, cond?: (n: Node) => boolean): Nullable<Node>;
    static findNotEmptySibling(node: Node, left: boolean): Nullable<Node>;
    static findNotEmptyNeighbor(node: Node, left: boolean, root: HTMLElement): Nullable<Node>;
    static sibling(node: Node, left?: boolean): Nullable<Node>;
    static up<T extends HTMLElement>(node: Nullable<Node>, condition: NodeCondition, root?: Node, checkRoot?: boolean): Nullable<T>;
    static closest<T extends HTMLElement, K extends HTMLTagNames>(node: Nullable<Node>, tags: K, root: HTMLElement): Nullable<HTMLElementTagNameMap[K]>;
    static closest<T extends HTMLElement, K extends keyof HTMLElementTagNameMap>(node: Nullable<Node>, tags: K[], root: HTMLElement): Nullable<HTMLElementTagNameMap[K]>;
    static closest<T extends HTMLElement>(node: Nullable<Node>, condition: NodeCondition, root: HTMLElement): Nullable<T>;
    static furthest<T extends HTMLElement>(node: Nullable<Node>, condition: NodeCondition, root: HTMLElement): Nullable<T>;
    static appendChildFirst(root: HTMLElement, newElement: HTMLElement | DocumentFragment): void;
    static after(elm: Node, newElement: Node | DocumentFragment): void;
    static before(elm: Node, newElement: Node | DocumentFragment): void;
    static prepend(root: Node, newElement: Node | DocumentFragment): void;
    static append(root: Node, newElements: Array<Node | DocumentFragment>): void;
    static append(root: Node, newElement: Node | DocumentFragment): void;
    static moveContent(from: Node, to: Node, inStart?: boolean): void;
    static isOrContains(root: Node, child: Node, onlyContains?: boolean): boolean;
    static safeRemove(...nodes: unknown[]): void;
    static safeInsertNode(range: Range, node: Node): void;
    static hide(node: Nullable<HTMLElement>): void;
    static show(node: Nullable<HTMLElement>): void;
    static isTag<K extends HTMLTagNames>(node: Node | null | undefined | false | EventTarget, tagName: K): node is HTMLElementTagNameMap[K];
    static isTag<K extends HTMLTagNames>(node: Node | null | undefined | false | EventTarget, tagNames: K[]): node is HTMLElementTagNameMap[K];
    static markTemporary<K extends HTMLElement>(element: K, attributes?: IDictionary): K;
    static isTemporary(element: unknown): boolean;
    static replaceTemporaryFromString(value: string): string;
    static temporaryList(root: HTMLElement): HTMLElement[];
}
